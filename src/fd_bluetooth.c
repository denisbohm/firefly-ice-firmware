#include "fd_nrf8001.h"
#include "fd_nrf8001_callbacks.h"
#include "fd_nrf8001_commands.h"
#include "fd_nrf8001_types.h"

#define PIPE_FIREFLY_ICE_LEDS_TX 1
#define PIPE_FIREFLY_ICE_LEDS_RX_ACK 2

#define NB_SETUP_MESSAGES 16
#define SETUP_MESSAGES_CONTENT {\
    {0x00,\
        {\
            0x07,0x06,0x00,0x00,0x03,0x02,0x41,0xd7,\
        },\
    },\
    {0x00,\
        {\
            0x1f,0x06,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x02,0x01,0x01,0x00,0x00,0x06,0x00,0x0a,\
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
        },\
    },\
    {0x00,\
        {\
            0x1f,0x06,0x10,0x1c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x90,0x01,0xff,\
        },\
    },\
    {0x00,\
        {\
            0x1f,0x06,0x10,0x38,0xff,0xff,0x02,0x58,0x00,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
        },\
    },\
    {0x00,\
        {\
            0x05,0x06,0x10,0x54,0x00,0x00,\
        },\
    },\
    {0x00,\
        {\
            0x1f,0x06,0x20,0x00,0x04,0x04,0x02,0x02,0x00,0x01,0x28,0x00,0x01,0x00,0x18,0x04,0x04,0x05,0x05,0x00,\
            0x02,0x28,0x03,0x01,0x0e,0x03,0x00,0x00,0x2a,0x04,0x14,0x0a,\
        },\
    },\
    {0x00,\
        {\
            0x1f,0x06,0x20,0x1c,0x0a,0x00,0x03,0x2a,0x00,0x01,0x46,0x69,0x72,0x65,0x66,0x6c,0x79,0x49,0x63,0x65,\
            0x04,0x04,0x05,0x05,0x00,0x04,0x28,0x03,0x01,0x02,0x05,0x00,\
        },\
    },\
    {0x00,\
        {\
            0x1f,0x06,0x20,0x38,0x01,0x2a,0x06,0x04,0x03,0x02,0x00,0x05,0x2a,0x01,0x01,0x00,0x00,0x04,0x04,0x05,\
            0x05,0x00,0x06,0x28,0x03,0x01,0x02,0x07,0x00,0x04,0x2a,0x06,\
        },\
    },\
    {0x00,\
        {\
            0x1f,0x06,0x20,0x54,0x04,0x09,0x08,0x00,0x07,0x2a,0x04,0x01,0xff,0xff,0xff,0xff,0x00,0x00,0xff,0xff,\
            0x04,0x04,0x02,0x02,0x00,0x08,0x28,0x00,0x01,0x01,0x18,0x04,\
        },\
    },\
    {0x00,\
        {\
            0x1f,0x06,0x20,0x70,0x04,0x10,0x10,0x00,0x09,0x28,0x00,0x01,0x99,0x63,0x84,0x81,0xa6,0xb7,0xbd,0xb0,\
            0x91,0x50,0x95,0x1b,0x01,0x00,0x0a,0x31,0x04,0x04,0x13,0x13,\
        },\
    },\
    {0x00,\
        {\
            0x1f,0x06,0x20,0x8c,0x00,0x0a,0x28,0x03,0x01,0x18,0x0b,0x00,0x99,0x63,0x84,0x81,0xa6,0xb7,0xbd,0xb0,\
            0x91,0x50,0x95,0x1b,0x02,0x00,0x0a,0x31,0x54,0x10,0x02,0x00,\
        },\
    },\
    {0x00,\
        {\
            0x16,0x06,0x20,0xa8,0x00,0x0b,0x00,0x02,0x02,0x00,0x00,0x46,0x14,0x03,0x02,0x00,0x0c,0x29,0x02,0x01,\
            0x00,0x00,0x00,\
        },\
    },\
    {0x00,\
        {\
            0x17,0x06,0x40,0x00,0x2a,0x00,0x01,0x00,0x00,0x04,0x00,0x03,0x00,0x00,0x00,0x02,0x02,0x00,0x12,0x04,\
            0x00,0x0b,0x00,0x0c,\
        },\
    },\
    {0x00,\
        {\
            0x13,0x06,0x50,0x00,0x99,0x63,0x84,0x81,0xa6,0xb7,0xbd,0xb0,0x91,0x50,0x95,0x1b,0x00,0x00,0x0a,0x31,\
        },\
    },\
    {0x00,\
        {\
            0x09,0x06,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\
        },\
    },\
    {0x00,\
        {\
            0x06,0x06,0xf0,0x00,0x03,0xc4,0x8d,\
        },\
    },\
}

#define HAL_ACI_MAX_LENGTH 31

typedef struct hal_aci_data_t {
  uint8_t status_byte;
  uint8_t buffer[HAL_ACI_MAX_LENGTH+1];
} hal_aci_data_t;

static const hal_aci_data_t setup_msgs[NB_SETUP_MESSAGES] = SETUP_MESSAGES_CONTENT;

static uint32_t credits;

static uint32_t setup_index;

void fd_bluetooth_initialize(void) {
    credits = 0;
}

void fd_nrf8001_device_started_event(
    uint8_t operating_mode,
    uint8_t hardware_error,
    uint8_t data_credit_available
) {
    credits = data_credit_available;

    switch (operating_mode) {
        case OperatingModeTest: {
        } break;
        case OperatingModeStandby: {
            uint16_t timeout = 0; // infinite advertisement - no timeout
            uint16_t interval = 32; // 20ms (0.625ms units)
            fd_nrf8001_connect(timeout, interval);
        } break;
        case OperatingModeSetup: {
            setup_index = 0;
            fd_nrf8001_setup_continue();
        } break;
    }
}

void fd_nrf8001_setup_continue(void) {
    if (setup_index >= NB_SETUP_MESSAGES) {
        return;
    }
    const hal_aci_data_t *setup_msg = &setup_msgs[setup_index++];
    uint8_t *buffer = (uint8_t *)setup_msg->buffer;
    uint32_t length = buffer[0] + 1;
    fd_nrf8001_send(buffer, length);
}

void fd_nrf8001_setup_complete(void) {
}

void fd_nrf8001_connect_success(void) {
}

void fd_nrf8001_connected_event(
    uint8_t address_type,
    uint8_t *peer_address,
    uint16_t connection_interval,
    uint16_t slave_latency,
    uint16_t supervision_timeout,
    uint8_t masterClockAccuracy
) {
    uint16_t interval_min = 16; // 20ms (1.25ms units)
    uint16_t interval_max = 32; // 40ms (1.25ms units)
    uint16_t latency = 0;
    uint16_t timeout = 600; // 6s (10ms units)
    fd_nrf8001_change_timing_request(interval_min, interval_max, latency, timeout);
}

void fd_nrf8001_pipe_status_event(uint64_t pipes_open, uint64_t pipes_closed) {
    for (int i = 1; i < 63; ++i) {
        if (pipes_closed & (1 << i)) {
            // !!! don't these opens need to be spread out over multiple transactions?
            fd_nrf8001_open_remote_pipe(i);
        }
    }
}

void fd_nrf8001_data_received_event(
    uint8_t service_pipe_number,
    uint8_t *data,
    uint32_t data_length
) {
}